# Lesson 2 Contents

+ [Truthiness](#truthiness)
+ [Virtual Environments](#virtual-environments-venv)
+ [Pseudocode](#pseudocode)
+ [Flowcharts](#flowcharts)
+ [Pylint](#pylint)
+ [Debugging](#debugging)
+ [Errors](#errors)
+ [Precedence](#precedence)
+ [Type Conversions](#type-conversions)

## Truthiness

### Booleans

These actually capture `True` and `False` rather than *truthy* and *falsy* - they are the definitive versions of truthiness  
[**Logical Operators**](#logical-operators) will evaluate their operands and return boolean value:

        num = 4
        num < 10    # True

The return of a Boolean isn't often useful, but *using* that returned Boolean value of a conditional expression is useful:

        num = 4
        if num < 3: # evaluates as True
            print('less than 3') # therefore, this line is executed
        else:
            print('3 or more')

### Logical Operators

#### `and`

+ Returns `True` when **all** sub-expressions evaluate to `True`
+ Sub-expressions can be chained and are evaluated from left to right:

        num = 10

        (num > 2) and (num < 15) and (num % 2 == 0)
            # True: between 2-15 and even

        (num > 2) and (num < 15) and (num % 2 == 1)
            # False: between 2-15 and odd

  + If **any** are `False`, the whole expression will return `False`
  + Parentheses not required (`<` and `>` have *higher* precedence than `and`), but it's clearer and foolproof to include them

#### `or`

+ Returns `True` when **either** sub-expression (the operands) evaluate to `True`
+ Can also be chained as above:

        num = 10

        (num > 2) or (num < 15) or (num % 2 == 0)
            # True: more than 2, or less than 15 or even

        (num > 2) or (num < 15) or (num % 2 == 1)
            # True: more than 2, or less than 15 or odd

#### `not`

+ Returns the inverse of the truth value of the condition ('logical negation'):

        num = 10
        
        num > 2         # True
        not (num > 2)   # False

### Short-Circuits

This is the idea that Python can stop evaluating sub-expressions if it already knows the evaluation of the whole expression

Expressions containing `and` and `or` exhibit this, as they move from left to right. They will short circuit when:

+ A sub-expression in an `and` expression evaluates as `False`
+ A sub-expression in an `or` expression evaluates as `True`

The remaining expressions are ***not*** evaluated which can be useful if they might contain exceptions (errors):

    if name != None and name.isupper():
        print(f"Hi, {name}.")
    else:
        print("Hello, whoever you are.")


  + Here, the variable `name` must be anything other than `None` to avoid an error. If it's in CAPS, it will print "Hi, {name}" but if not, it will print ("Hello, whoever you are.")  
  + If `name = None` and the `name != None and` code wasn't there, we would get an error

### Truthy and Falsy

These describe the nature of the values `True` and `False` - the former is obviously truthy and the latter falsy, but what about other values?  
Most are truthy, the exceptions are as follows:

+ False
+ None
+ 0
+ 0.0
+ 0j
+ "" (an empty string)
+ [] (an empty list)
+ {} (an empty dictionary)
+ () (an empty tuple)
+ set() (an empty set)
+ frozenset() (an empty frozenset)
+ range(0) (an empty range)

Values don't have to be `True` to be truthy:

        num = 5
        if num:
            print('truthy value')
        else:
            print('falsy value')

  + Note that `num` does not equal `True`, it is simply *truthy*

Using `if name` to test for empty strings works, but is discouraged  
Instead, use `if name == ''` to test for empty strings


## Virtual Environments (venv)

+ These are created to enable programs to be run within them that may need different software versions
+ Instead of changing PATHs to run an older software version, install all versions and then just set them up in the venv depending on the program's needs 
+ You can then activate/deactivate the venv and it will have the versions you need

1. Create a directory (~/.venv) to store them in 
2. `python3.9 -m venv ~/.venv/env_a`
   + uses Python 3.9 to create a venv called 'env_a'
   + `-m venv` tells Python to run the venv module
3. `source ~/.venv/env_a/bin/activate`
   + activates env_a
4. `deactivate`
   + returns to default environment and versions

## Pseudocode

Code for humans - in plain english and describes a logical process (logical domain layer)

The second part is the syntactical programming language layer (i.e. actually writing the code) doing both at once is hard

The issue is that can't verify that it works programmatically

### Formal Pseudocode

        Keyword	    Meaning
        START	    start of the program
        SET	        set a variable that we can use for later
        GET	        retrieve input from user
        PRINT	    display output to user
        READ	    retrieve a value from a variable
        IF/ELSE 	show conditional branches in logic
        WHILE	    show looping logic
        SUBPROCESS  self-contained block of logic
        END	        end of the program

Using the above keywords, we can make the pseudocode a bit easier more universal and slightly closer to real code, but it still can't be verified

*Example*: "Write a function that takes one integer argument and returns `True` when the number's absolute value is odd, `False` otherwise."

*Pseudocode*:

+ Take a single input
+ Check if it is an integer and return a prompt if not
+ Ensure we take the absolute value of the integer
+ Check if it is odd, return True if so
+ Otherwise, return False

*Formal Pseudocode*:

        START
        READ argument from function call
        IF input type is not an integer:
            PRINT prompt for an integer
        IF input type is an integer:
            READ absolute value of input
            IF result of dividing input by 2 is 1:
                PRINT True
            IF result of dividing input by 2 is not 1:
                PRINT False
        END

See [Exercise 1](../lesson_1/easy_1/01%20Isn't%20it%20Odd) for Python code

For large projects, we can't put the whole thing into pseudocode and hope to translate it into formal pseudocode and then programming language; we need to take each piece step by step to test the logic, before moving on to the next piece.

Further examples from Lesson 2 can be found [here](./Pseudocode%20Practice)

## Flowcharts

These show the logic flow to solve the problem - called the imperative/procedural way  
Pseudocode can be converted into a flowchart but can include sub-processes (in rectangle boxes) that have self-contained functionality 

## Pylint

Static code analyser:

+ Enforces good style guide - PEP 8
+ Identifies potential logic errors - code linter:
  + Convention - standard programming violations
  + Refactor - bad code smell
  + Warning - python specific
  + Error - broken code
  + Fatal - prevent further processing
  
+ Rules can be configured using a `.pylintrc` file (usually created in the project directory)
  + Must sit in the directory that the project you are running is in

## Debugging

Many techniques exits and vary from person to person; some options include:

+ Reproduce the error
+ Determine the boundaries of the error - which part of the line has the error
  + The explanation of the error may help here
+ Trace the code - the stack trace shows how far the program got before the error, so this shows that anything above the error line is fine (known as 'trapping the error')
+ Understand the problem well - what is the actual programmatic issue?
+ Implement a fix - `try` clauses are not fixing problem origin, merely putting a plaster on them (but may be all that's available to you if the code isn't yours).
  + Fix the source of the error if possible, right back at the origin
  + Fix one problem at a time
  + Test it - use manual inputs to check edge cases
  
#### Techniques

+ Go line by line - be patient and read the details
+ Rubber duck debugging - can help notice previously missed details
+ Walk away - after the problem is 'loaded' into your brain
+ Use `print` at carefully placed positions to analyse the code
+ Use a debugger, like pdb:
  + Insert `breakpoint()` and run the code
  + Use `c` to step through until the next breakpoint
  + Use `n` to step through the next line
  + Use `p` and a variable or expression to check the expected outcomes

## Errors

These are actually **exception objects** which are created when the interpreter cannot continue executing the program: the object describes the problem and stops the program

### Terminology

Python *raises* an exception but *throwing* exceptions/errors are common phrases

#### NameError

+ Using a variable or function that is undefined

#### TypeError

+ Using a value of the wrong type in an expression

        word = 'hello'
        word.find(42) # TypeError

+ Calling an object that isn't callable

        number = 42
        number() # TypeError

#### SyntaxError

+ These are unique as they arises after loading the program, but *before* it runs
+ Encounters code that break syntactic rules, e.g. missing trailing quote:

        print('hello) # SyntaxError

#### ValueError

+ Using the correct data type, but the value is inappropriate for the operation

        number = int('abc') # ValueError
        number = int('45') # number reassigned to 45

#### IndexError

+ Trying to access an index outside the range

        numbers = [1, 2]
        numbers[2] # IndexError

#### KeyError

+ Trying to access a dictionary key that doesn't exist

        dictionary = {'Barry': 5, 'Gary' : 4, 'Harry' : 5}
        dictionary['Barry'] # 5
        dictionary['Larry'] # KeyError

#### ZeroDivisionError

+ Dividing by zero either using `/` or `%`

        result_1 = 10 / 0 # ZeroDivisionError: division by zero
        result_2 = 10 % 0 # ZeroDivisionError: integer modulo by zero

### Exception Handling

+ Allows you to try and manage errors using statements:
  + `try`
  + `except`
  + `else`
  + `finally`

1. The code that might raise the exception is placed inside the `try` block  
   a. Python will monitor the block for exceptions
2. If one is found, Python will look for a matching `except` block to handle the specific type of exception  
   a. If a match is found, the code within the `except` block is run
3. If no exceptions are in the `try` block are raised, this code runs
4. Any code in the `finally` block runs regardless of any exceptions being raised 

Example:

    try:
        num_str = input("Enter a number: ")
        num = int(num_str)

        result = 10 / num
    except ValueError:
        print("Invalid input. Please enter a valid number.")
    except ZeroDivisionError:
        print("Cannot divide by zero.")
    else:
        print(f"Result: {result}")
    finally:
        print("Exception handling complete.")

This catches occurrences when use enters something that isn't an integer (such as a float, or string), or 0

### Preventing Errors

#### Look Before You Leap (LBYL)

+ This process checks for potential errors prior to executing, typically using guard clauses that return an output if some specific criteria aren't met  
+ For example, you need an argument to be a string for the function to run:

        if type(arg) != str:
            return arg

+ This just returns the argument if it's not a string, instead of throwing an error
+ Guard clauses are best used to ensure arguments are valid, unless you are confident that the argument will always be a string (e.g. via prior confident programming)


#### It's Easier to Ask Forgiveness than Permission (EAFP)

+ Typically this process uses [exception handling](#exception-handling)
+ Tries code without any explicit checks/guard clauses and deals with exceptions
  
### Edge Cases

+ These involve dealing with values at the edges of potential value ranges
+ E.g.:
  + Expecting a number but we have 0, or a negative
  + Expecting a whole number but getting a float or a fraction
  + Expecting a collection but getting an empty collection
  + Dealing with leading/trailing white space, special characters or solely spaces
+ Worth testing some edge cases to evaluate the code

## Precedence

+ Not necessarily simply the order that operators are evaluated, but that's the basic idea
+ Don't rely on you/others knowing the precedence, use parentheses to make it clear
+ Operators with high precedence *bind* to their operands more tightly:

        3 + 5 * 7 # 38

  + `*` binds more tightly to `5` and `7` and is evauluated first
  + `+` then binds to `3` and `35`

+ Python will go through an expression and evaluate what it can *without* calling operators:

        def value(n):
            print(n)
            return n
        
        print(value(3) + value(5) * value(7))

  + The functions are evaluated before the operands, therefore it prints each number on a separate line, and then the evaluation of `3 + 5 * 7` which, from before, is `38`

#### Short-circuiting

+ This is a special case and Python treats `and` and `or` differently:

        5 and 1 / 0           # ZeroDivisionError
        None or 1 / 0         # ZeroDivisionError

        None and 1 / 0           # None
        5 or 1 / 0               # 5
  + The division is *not* done first in the second 2 examples, instead, they short-circuit and return the first operand - the `1 / 0` expression is never evaluated

## Type Conversions

+ Process of converting one type into another - also known as 'coercion' and has two variations: explicit and implicit

### Explicit Coercion

Intentional use of a built-in function to covert one to another:

#### Values to Integers

+ `int`()
+ Will only work with 'numerical' strings, e.g.
  + '500' - returns 500
  + 5.42 - returns 5
  + Byte-like objects (not discussed now)
  + True/False - returns 1/0

+ On a non-numerical string, will raise `ValueError`, e.g.
  + 'abc' - returns ValueError

+ On any other type, it will raise a `TypeError`

#### Values to Floats

+ `float`()
+ Works similarly to `int()`, other than...
+ Special 'Non-a-Number' value: `nan` - arises from operations with no meaningful result:
      
        result = float('inf') - float('inf') # nan
+ Note than `float('NaN')` returns `nan`

#### Values to Strings

+ `str()`
+ Works with all built-in data types
+ The `print()` function automatically coerces its arguments to strings, but isn't considered coercion as it doesn't return strings, it prints them
+ String interpolation ('f-strings') coerces the values in the expression to strings

        name = 'George'
        age = 28
        print(f'My name is {name} and I am {age})
        # `name` and `age` are converted to strings
+ `repr() `is similar but returns the string representation of the object:
  + Note that when you use the `print()` function, it strips away the quotes:
    + [feedback on repr() vs str() - assingment 20]

#### Values to Booleans

+ `bool()`
+ Works will all built-in data types and non-built-in values
+ It uses the truthiness to evaluate as `True` or `False`

        bool(None) # False
        bool([1, 2, 3]) # True

### Implicit Coercion

+ Also known as automatic coercion - without programmer's direct instruction

#### Combining Integer and Float

+ Python automatically converts the integer to a float before the operation
  + The result will be a float

#### Combining String with Non-string

+ Combining a string with a number will raise a `TypeError`
+ This is different in the `print()` function which converts integers to strings before printing (not considered coercion as it takes place behind the scenes)

